// Copyright Â© 2015-2016 Kevin Robert Stravers
/*
This file is part of Cxy Compiler Reference Implementation (Cxy CRI).

Cxy CRI is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Cxy CRI is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Cxy CRI.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once
#include <cstddef>
#include <limits>
#include <string>
#include <vector>


namespace action {

/**
	The token generator uses the actions generated by the ActionGenerator
	in order to put ins into tokens. When the token is ready is
	pushes the token into a vector and signals via consumeCharacter that
	a certain number of tokens have been added.
	[ a b c d ]
	a '-' is pushed:
	[ a b c d - ]
	The token stack can now output 'abcd' as a single token.
*/
template<typename Action, typename EntryType, typename Token, typename TokenType>
class TokenGenerator
{
private:

	std::vector<Token> token_stack;
	std::string        current_working_lexeme;

public:

	std::size_t consumeCharacter(char in, Action action)
	{
		auto &cwl = current_working_lexeme;
		auto &tostac = token_stack;
		switch (action)
		{
			case Action::N:
				return 0;
			break;
			case Action::P:
				cwl.push_back(in);
				return 0;
			break;
			case Action::E:
				return std::numeric_limits<std::size_t>::max();
			break;
			case Action::PTG:
				cwl.push_back(in);
				token_stack.emplace_back(Token {0, 0, EntryType::GROUPING_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 1;
			break;
			case Action::TAPTG:
				token_stack.emplace_back(Token {0, 0, EntryType::ALPHA_DIGIT_OR_UNDERSCORE, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				token_stack.emplace_back(Token {0, 0, EntryType::GROUPING_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 2;
			break;
			case Action::TA:
				token_stack.emplace_back(Token {0, 0, EntryType::ALPHA_DIGIT_OR_UNDERSCORE, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 1;
			break;
			case Action::TAP:
				token_stack.emplace_back(Token {0, 0, EntryType::ALPHA_DIGIT_OR_UNDERSCORE, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				return 1;
			break;
			case Action::TRP:
				token_stack.emplace_back(Token {0, 0, EntryType::QUOTE_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				return 1;
			break;
			case Action::TRPTG:
				token_stack.emplace_back(Token {0, 0, EntryType::QUOTE_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				token_stack.emplace_back(Token {0, 0, EntryType::GROUPING_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 2;
			break;
			case Action::TSP:
				token_stack.emplace_back(Token {0, 0, EntryType::OTHER_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				return 1;
			break;
			case Action::TSPTG:
				token_stack.emplace_back(Token {0, 0, EntryType::OTHER_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				cwl.push_back(in);
				token_stack.emplace_back(Token {0, 0, EntryType::GROUPING_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 2;
			break;
			case Action::TS:
				token_stack.emplace_back(Token {0, 0, EntryType::OTHER_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 1;
			break;
			case Action::TR:
				token_stack.emplace_back(Token {0, 0, EntryType::QUOTE_SYMBOL, TokenType::UNIDENTIFIED, std::move(cwl)} );
				return 1;
			break;
			default:
			break;
		}
		return 0;
	}

	std::vector<Token> &getTokenStack() {
		return token_stack;
	}

	const std::vector<Token> &getTokenStack() const {
		return token_stack;
	}

};

}
